---
title: "AI '학습'이라는 용어에 속지 마세요"
date: 2025-12-05T15:00:00+09:00
draft: false
slug: "ai-training-inference-explained"
tags:
  - AI
  - LLM
  - 개발자 가이드
categories:
  - AI
translationKey: "ai-training-inference-explained"
cover:
  image: "images/posts/ai-training-inference-explained.jpg"
  alt: "AI와 개발을 상징하는 이미지"
description: "AI 모델의 '학습'은 빌드타임, '추론'은 런타임에 해당합니다. 서비스에 배포된 모델은 실시간으로 배우지 않으며, 개발자가 할 일은 좋은 데이터(RAG)와 프롬프트를 제공하는 것입니다."
tldr: "AI 모델의 '학습'은 빌드타임, '추론'은 런타임에 해당합니다. 서비스에 배포된 모델은 실시간으로 배우지 않으며, 개발자가 할 일은 좋은 데이터(RAG)와 프롬프트를 제공하는 것입니다."
---

서비스 개발을 하는 동료들과 이야기를 나누다 보면, AI 도입에 대해 막연한 부담감을 느끼는 경우를 종종 봅니다. 그 부담감의 근원을 파고들면 대개 **'학습(Training)'**이라는 용어가 주는 오해에서 비롯됩니다.

> "모델을 서비스에 붙이면, 유저 데이터를 먹고 실시간으로 학습해서 똑똑해지는 건가요?"
> "그럼 그 학습 과정을 우리가 통제할 수 있나요? 이상한 걸 배우면 어떡하죠?"

만약 이런 고민을 하고 계셨다면, 잠시 걱정을 내려놓으셔도 좋습니다. 오늘 그 오해를 개발자의 언어로 풀어드리겠습니다.

## '학습'은 빌드타임, '추론'은 런타임

가장 먼저 바로잡아야 할 것은, **우리가 서비스에 배포하는 AI 모델은 대부분 '얼어있는(Frozen)' 상태**라는 점입니다.

개발 용어로 비유하면 다음과 같습니다.

| 개념 | AI 용어 | 개발 용어 비유 | 설명 |
|------|---------|----------------|------|
| 모델 만들기 | 학습(Training) | 빌드타임(Build Time) | 엄청난 리소스와 시간이 필요 |
| 모델 사용하기 | 추론(Inference) | 런타임(Runtime) | 요청을 받아 결과를 반환 |

우리가 서비스를 운영할 때, 실행 중인 바이너리 코드가 스스로 자기 코드를 수정하며 진화하지 않습니다. AI도 마찬가지입니다.

모델은 배포되는 순간, 더 이상 '배우는 학생'이 아니라 **'지시대로 일하는 노동자'**가 됩니다. 우리가 걱정해야 할 영역은 학습이 아니라, 이 노동자가 일을 잘하도록 환경을 만들어주는 것입니다.

## 도서관 비유로 이해하는 AI 구조

그렇다면 최신 정보는 어떻게 반영하고, AI는 어떤 역할을 하는 걸까요? 저는 이 구조를 **'도서관'**에 비유하곤 합니다.

| 구성 요소 | 도서관 비유 | 설명 |
|-----------|-------------|------|
| AI 모델 (LLM) | 사서 | 언어 능력과 추론 능력을 갖춘 존재 |
| RAG / DB | 서고 | 서비스 데이터와 최신 정보가 저장된 공간 |
| 프롬프트 | 업무 지시서 | 사서에게 일을 시킬 때 주는 가이드라인 |

서비스 개발자인 우리가 매일 하는 일은 **'도서관에 신간을 채워 넣는 일(DB 업데이트)'**입니다. 사서(AI)는 우리가 채워 넣은 책을 필요할 때 꺼내서(Retrieve), 내용을 읽고 조합해서 사용자에게 전달(Inference)할 뿐입니다.

여기서 많은 분이 두려워하는 **'학습(Fine-tuning)'**은 **'사서를 대학원에 보내 재교육시키는 일'**에 해당합니다. 사서가 기본적인 문해력이 부족하거나, 일반적인 상식으로는 이해할 수 없는 특수 도메인을 다뤄야 할 때만 필요한 엣지 케이스입니다.

대부분의 비즈니스 문제는 사서를 재교육(학습)시키는 것이 아니라, 다음 세 가지로 해결됩니다:

1. **똑똑한 사서 채용** - 좋은 기본 모델 선택
2. **좋은 업무 매뉴얼** - 잘 설계된 프롬프트
3. **정리된 서고** - 구조화된 RAG/DB

## AI는 '의미 처리 가속기'다

이렇게 구조를 파악하고 나면, AI는 더 이상 두려운 미지의 존재가 아닙니다. 그저 우리 시스템 아키텍처에 꽂아야 할 하나의 **'부품'**일 뿐입니다.

컴퓨터의 역사는 '처리의 가속화'였습니다.

| 하드웨어 | 가속화 대상 |
|----------|-------------|
| CPU | 계산과 로직(if-else) 처리 |
| GPU | 그래픽과 픽셀 처리 |
| AI (LLM) | 의미(Semantics)와 맥락(Context) 처리 |

우리는 그동안 `if (text.contains("사과"))` 같은 코드로 인간의 언어를 기계적으로 처리하느라 고생했습니다. 이제는 그 '의미 처리'를 전담해 주는 고성능 가속기(AI)가 생긴 것입니다.

## 마치며

AI 시대라고 해서 개발자가 AI 모델을 직접 만들거나 수식을 이해해야 한다는 강박을 가질 필요는 없습니다.

우리가 MySQL의 내부 엔진 소스코드를 몰라도 훌륭한 백엔드 서버를 구축할 수 있듯이, AI라는 **'똑똑한 사서'**를 우리 서비스의 어느 데스크에 앉히고, 어떤 권한을 줄지 설계하는 **아키텍처링 능력**은 여전히 유효하며 더 중요해졌습니다.

AI에 과도한 의미를 부여하지 마십시오. 그것은 스스로 생각하고 반란을 일으키는 인공지능이 아니라, 우리가 입력한 데이터를 확률적으로 가장 그럴듯하게 처리해서 반환하는 **'함수(Function)'**이자 **'도구(Tool)'**입니다.

도구는 두려워할 대상이 아니라, 손에 익혀서 잘 써먹어야 할 대상입니다.
